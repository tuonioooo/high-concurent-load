# CDN缓存更新策略

### 概述

**缓存是什么？**

缓存是一个到处都存在的用空间换时间的例子。通过使用多余的空间，我们能够获取更快的速度。  
首先，看看没有网站没有接入CDN时，用户浏览器与服务器是如何交互的：

![](https://upload-images.jianshu.io/upload_images/6871092-c56c2322cfab46e6.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240 "1.png")

用户在浏览网站的时候，浏览器能够在本地保存网站中的图片或者其他文件的副本，这样用户再次访问该网站的时候，浏览器就不用再下载全部的文件，减少了下载量意味着提高了页面加载的速度。

中间加上一层CDN，那么用户浏览器与服务器的交互如下：

![](https://upload-images.jianshu.io/upload_images/6871092-bf8e7a9758b9f75a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240 "2.png")

客户端浏览器先检查是否有本地缓存是否过期，  
如果过期，则向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个完成http请求结束；  
如果数据已经过期，那么CDN还需要向源站发出回源请求（back to the source request）,来拉取最新的数据。  
浏览器缓存策略

### 缓存策略

**Expires策略**

Expires是web服务器 响应消息头字段，在响应http请求时告诉浏览器在过期时间前，浏览器可以直接从浏览器缓存读取数据，而无需再次请求，它的值对应一个GMT（格林尼治时间），比如“Mon, 22 Jul 2012 11:15:08 GMT”来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。  
不过Expires是HTTP 1.0的东西。  
现在浏览器都是默认HTTP 1.1的了。所以基本可以忽略它。

Expires有一个缺点，就是它的过期时间是服务器的时间，比如我的客户端时间和服务器时间相差很大，那误差就很大。

比如服务器返回的是2016年7月16号过期，我的电脑时间被我修改了，快了一天为2016年7月17号，那客户端缓存就过期了。所以它被Cache-Control：max-age=秒 替代了。

  
**Cache-control策略**

Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。

只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。

Cache-Control可拥有如下值：

> **Public**  
> 任何情况下都得缓存该资源。  
> **Private**  
> 指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。缓存只开放给某些特定的用户，比如服务器的用户，其他用户则不能缓存这些数据。  
> **no-cache**  
> 指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，容易望文生义~。要求向服务器发起新鲜度检验  
> **no-store**  
> 用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。主要用于一些机密文件  
> **max-age**  
> 指示客户端该端时间内缓存都是最新的。以秒为单位。比如：Cache-Control：max-age=120 表示2分钟之后过期。  
> **min-fresh**  
> 指示客户端希望获取一个在小于指定的时间内被更新过的资源，单位为秒：例如：Cache-Control：min-fresh =120 。向服务器获取2分钟内被更新过的资源  
> **max-stale**  
> 指示客户端可以接收超出超时期间的响应消息。例如：Cache-Control：max-stale =120 ，向服务器获取超过缓存时间2分钟的资源。  
> must-revalidate:作用与no-cache相同，但更严格，强制意味更明显

**Last-Modified：**  
　　标示这个响应资源的最后修改时间，web服务器在响应请求时，告诉浏览器资源的最后修改时间。

**If-Modified-Since：**  
　　当资源过期时（也就是Cache-Control:max-age=0，），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若Last-Modified的时间较新，说明最后修改时间较新，说明资源又被改动过，则响应整的资源重新从服务器读取，而不是读取缓存，返回200状态吗；若If-Modified-Since的时间比Last-Modified新或者相等，说明服务器的内容没有更新，直接读取缓存即可，返回304状态码，告知浏览器继续使用所保存的cache

**Etag**

通常情况下，通过修改时间来比较文件是可行的。但是在一些特殊情况，例如服务器的时钟发生了错误，服务器时钟进行修改，夏时制DST到来后服务器时间没有及时更新，这些都会引起通过修改时间比较文件版本的问题。

ETag可以用来解决这种问题。ETag是一个文件的唯一标志符。就像一个哈希或者指纹，每个文件都有一个单独的标志，只要这个文件发生了改变，这个标志就会发生变化。

**浏览器缓存刷新**

1. 在地址栏中输入网址后按回车或点击转到按钮  
   浏览器以最少的请求来获取网页的数据，浏览器会对所有没有过期的内容直接使用本地缓存，从而减少了对浏览器的请求。所以，Expires，max-age标记只对这种方式有效。

2. 按F5或浏览器刷新按钮  
   浏览器会在请求中附加必要的缓存协商，但不允许浏览器直接使用本地缓存，它能够让 Last-Modified、ETag发挥效果，但是对Expires无效。

3. 按Ctrl+F5或按Ctrl并点击刷新按钮  
   这种方式就是强制刷新，总会发起一个全新的请求，不使用任何缓存。

**CDN缓存**

浏览器本地缓存失效后，浏览器会向CDN边缘节点发起请求。类似浏览器缓存，CDN边缘节点也存在着一套缓存机制。

**CDN缓存的缺点**

CDN的分流作用不仅减少了用户的访问延时，也减少的源站的负载。但其缺点也很明显：当网站更新时，如果CDN节点上数据没有及时更新，即便用户再浏览器使用Ctrl+F5的方式使浏览器端的缓存失效，也会因为CDN边缘节点没有同步最新数据而导致用户访问异常。

**CDN的缓存机制**

CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的Cache-control: max-age的字段来设置CDN边缘节点数据缓存时间。

当客户端向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向源站发出回源请求，从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。所以，如果我们修改了内容，最好加个版本号，来容CDN重新获取资源，从而减少不必要的麻烦，比如 :

app.js?v=20171114 或者 style.css?v=20171114

**CDN缓存刷新**

CDN边缘节点对开发者是透明的，相比于浏览器Ctrl+F5的强制刷新来使浏览器本地缓存失效，开发者可以通过CDN服务商提供的“刷新缓存”接口来达到清理CDN边缘节点缓存的目的。这样开发者在更新数据后，可以使用“刷新缓存”功能来强制CDN节点上的数据缓存过期，保证客户端在访问时，拉取到最新的数据。



